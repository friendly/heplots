% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gsorth.R
\name{gsorth}
\alias{gsorth}
\title{Orthogonalize successive columns of a data frame or matrix}
\usage{
gsorth(y, order, recenter = TRUE, rescale = TRUE, adjnames = TRUE)
}
\arguments{
\item{y}{A numeric data frame or matrix}

\item{order}{An integer vector specifying the order of and/or a subset of
the columns of \code{y} to be orthogonalized. If missing, \code{order=1:p}
where \code{p=ncol(y)}.}

\item{recenter}{If \code{TRUE}, the result has same column means as
original; else means = 0 for cols \code{2:p}.}

\item{rescale}{If \code{TRUE}, the result has same column standard
deviations as original; else sd = residual variance for cols \code{2:p}}

\item{adjnames}{If \code{TRUE}, the column names of the result are adjusted
to the form Y1, Y2.1, Y3.12, by adding the suffixes '.1', '.12', etc. to the
original column names.}
}
\value{
Returns a matrix or data frame with uncorrelated columns.  Row and
column names are copied to the result.
}
\description{
\code{gsorth} uses sequential, orthogonal projections, as in the
Gram-Schmidt method, to transform a matrix or numeric columns of a data
frame into an uncorrelated set, possibly retaining the same column means and
standard deviations as the original.
}
\details{
In statistical applications, interpretation depends on the \code{order} of
the variables orthogonalized. In multivariate linear models, orthogonalizing
the response, Y variables provides the equivalent of step-down tests, where
Y1 is tested alone, and then Y2.1, Y3.12, etc. can be tested to determine
their additional contributions over the previous response variables.

Similarly, orthogonalizing the model X variables provides the equivalent of
Type I tests, such as provided by \code{\link[stats]{anova}}.

The method is equivalent to setting each of columns \code{2:p} to the
residuals from a linear regression of that column on all prior columns,
i.e.,

\code{z[,j] <- resid( lm( z[,j] ~ as.matrix(z[,1:(j-1)]), data=z) )}

However, for accuracy and speed the transformation is carried out using the
QR decomposition.
}
\examples{

GSiris <- gsorth(iris[,1:4])
GSiris <- gsorth(iris, order=1:4)   # same, using order
str(GSiris)
zapsmall(cor(GSiris))
colMeans(GSiris)
# sd(GSiris) -- sd(<matrix>) now deprecated
apply(GSiris, 2, sd)

# orthogonalize Y side
GSiris <- data.frame(gsorth(iris[,1:4]), Species=iris$Species)
iris.mod1 <- lm(as.matrix(GSiris[,1:4]) ~ Species, data=GSiris)
Anova(iris.mod1)

# orthogonalize X side
rohwer.mod <- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer)
Anova(rohwer.mod)

# type I tests for Rohwer data
Rohwer.orth <- cbind(Rohwer[,1:5], gsorth(Rohwer[, c("n", "s", "ns", "na", "ss")], adjnames=FALSE))

rohwer.mod1 <- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer.orth)
Anova(rohwer.mod1)
# compare with anova()
anova(rohwer.mod1)

# compare heplots for original Xs and orthogonalized, Type I
heplot(rohwer.mod)
heplot(rohwer.mod1)


}
\seealso{
\code{\link[base]{qr}},
}
\author{
Michael Friendly
}
\keyword{manip}
