% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/robmlm.R
\name{robmlm}
\alias{robmlm}
\alias{print.robmlm}
\alias{print.summary.robmlm}
\alias{robmlm.default}
\alias{robmlm.formula}
\alias{summary.robmlm}
\title{Robust Fitting of Multivariate Linear Models}
\usage{
robmlm(X, ...)

\method{robmlm}{default}(
  X,
  Y,
  w,
  P = 2 * pnorm(4.685, lower.tail = FALSE),
  tune,
  max.iter = 100,
  psi = psi.bisquare,
  tol = 1e-06,
  initialize,
  verbose = FALSE,
  ...
)

\method{robmlm}{formula}(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  contrasts = NULL,
  ...
)

\method{print}{robmlm}(x, ...)

\method{summary}{robmlm}(object, ...)

\method{print}{summary.robmlm}(x, ...)
}
\arguments{
\item{X}{for the default method, a model matrix, including the constant (if
present)}

\item{\dots}{other arguments, passed down. In particular relevant control
arguments can be passed to the to the \code{robmlm.default} method.}

\item{Y}{for the default method, a response matrix}

\item{w}{prior observation weights}

\item{P}{two-tail probability, to find cutoff quantile for chisq (tuning
constant); default is set for bisquare weight function}

\item{tune}{tuning constant (if given directly)}

\item{max.iter}{maximum number of iterations}

\item{psi}{robustness weight function; \code{\link[MASS]{psi.bisquare}} is
the default}

\item{tol}{convergence tolerance, maximum relative change in coefficients}

\item{initialize}{modeling function to find start values for coefficients,
equation-by-equation; if absent WLS (\code{lm.wfit}) is used}

\item{verbose}{show iteration history? (\code{TRUE} or \code{FALSE})}

\item{formula}{a formula of the form \code{cbind(y1, y2, ...) ~ x1 + x2 + ...}.}

\item{data}{a data frame from which variables specified in \code{formula}
are preferentially to be taken.}

\item{subset}{An index vector specifying the cases to be used in fitting.}

\item{weights}{a vector of prior weights for each case.}

\item{na.action}{A function to specify the action to be taken if \code{NA}s
are found.  The 'factory-fresh' default action in R is
\code{\link[stats]{na.omit}}, and can be changed by
\code{\link[base]{options}}\verb{(na.action=)}.}

\item{model}{should the model frame be returned in the object?}

\item{contrasts}{optional contrast specifications; see
\code{\link[stats]{lm}} for details.}

\item{x}{a \code{robmlm} object}

\item{object}{a \code{robmlm} object}
}
\value{
An object of class \code{"robmlm"} inheriting from \code{c("mlm", "lm")}.

This means that the returned \code{"robmlm"} contains all the components of
\code{"mlm"} objects described for \code{\link[stats]{lm}}, plus the
following:
\describe{
\item{weights }{final observation weights}
\item{iterations }{number of iterations}
\item{converged }{logical: did the IWLS process converge?}
}

The generic accessor functions \code{\link[stats]{coefficients}},
\code{\link[stats]{effects}}, \code{\link[stats]{fitted.values}} and
\code{\link[stats]{residuals}} extract various useful features of the value
returned by \code{robmlm}.
}
\description{
Fit a multivariate linear model by robust regression using a simple M
estimator that down-weights observations with large residuals

Fitting is done by iterated re-weighted least squares (IWLS), using weights
based on the Mahalanobis squared distances of the current residuals from the
origin, and a scaling (covariance) matrix calculated by
\code{\link[MASS]{cov.trob}}. The design of these methods were loosely
modeled on \code{\link[MASS]{rlm}}.

These S3 methods are designed to provide a specification of a class of
robust methods which extend \code{mlm}s, and are therefore compatible with
other \code{mlm} extensions, including \code{\link[car]{Anova}} and
\code{\link{heplot}}.

An internal \code{vcov.mlm} function is an extension of the standard
\code{\link[stats]{vcov}} method providing for the use of observation weights.
A \code{\link{plot.robmlm}} method provides simple index plots of case weights
to visualize those that were down-weighted.
}
\details{
Weighted least squares provides a method for correcting a variety of problems in linear models
by estimating parameters that minimize the \emph{weighted} sum of squares of residuals
\eqn{\Sigma w_i e_i^2} for specified weights \eqn{w_i, i = 1, 2, \dots n}.

M-estimation generalizes this by minimizing the sum of a symmetric function
\eqn{\rho(e_i)} of the residuals, where the function is designed to reduce the influence
of outliers or badly fit observations. The function \eqn{\rho(e_i) = | e_i |}
minimizes the least absolute values, while the \emph{bisquare} function uses an upper bound
on influence. For multivariate problems, a simple method is to use Mahalanobis \eqn{D^2 (\mathbf{e}_i)}
to calculate the weights.

Because the weights and the estimated coefficients depend on each other, this is done
iteratively, computing weights and then re-estimating the model with those weights
until convergence.
}
\examples{

# Skulls data
# -----------
data(Skulls)

# make shorter labels for epochs and nicer variable labels in heplots
Skulls$epoch <- factor(Skulls$epoch, labels=sub("c","",levels(Skulls$epoch)))
# variable labels
vlab <- c("maxBreadth", "basibHeight", "basialLength", "nasalHeight")

# fit manova model, classically and robustly
sk.mod <- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
sk.rmod <- robmlm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)

# standard mlm methods apply here
coefficients(sk.rmod)

# index plot of weights
plot(sk.rmod, segments = TRUE, col = Skulls$epoch)
points(sk.rmod$weights, pch=16, col=Skulls$epoch)
text(x = 15+seq(0,120,30), y = 1.05, labels=levels(Skulls$epoch), xpd=TRUE)

# heplots to see effect of robmlm vs. mlm
heplot(sk.mod, hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
    xlab=vlab[1], ylab=vlab[2], cex=1.25, lty=1)
heplot(sk.rmod, hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
    add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, hyp.labels=FALSE, err.label="")

##############
# Pottery data

data(Pottery, package = "carData")
pottery.mod <- lm(cbind(Al,Fe,Mg,Ca,Na)~Site, data=Pottery)
pottery.rmod <- robmlm(cbind(Al,Fe,Mg,Ca,Na)~Site, data=Pottery)
car::Anova(pottery.mod)
car::Anova(pottery.rmod)

# index plot of weights
plot(pottery.rmod$weights, type="h")
points(pottery.rmod$weights, pch=16, col=Pottery$Site)

# heplots to see effect of robmlm vs. mlm
heplot(pottery.mod, cex=1.3, lty=1)
heplot(pottery.rmod, add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, err.label="")

###############
# Prestige data
data(Prestige, package = "carData")

# treat women and prestige as response variables for this example
prestige.mod <- lm(cbind(women, prestige) ~ income + education + type, data=Prestige)
prestige.rmod <- robmlm(cbind(women, prestige) ~ income + education + type, data=Prestige)

coef(prestige.mod)
coef(prestige.rmod)
# how much do coefficients change?
round(coef(prestige.mod) - coef(prestige.rmod),3)

# pretty plot of case weights
plot(prestige.rmod$weights, type="h", xlab="Case Index", ylab="Robust mlm weight", col="gray")
points(prestige.rmod$weights, pch=16, col=Prestige$type)
legend(0, 0.7, levels(Prestige$type), pch=16, col=palette()[1:3], bg="white")

heplot(prestige.mod, cex=1.4, lty=1)
heplot(prestige.rmod, add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, err.label="")



}
\references{
A. Marazzi (1993) \emph{Algorithms, Routines and S Functions for
Robust Statistics}.  Wadsworth & Brooks/Cole.
}
\seealso{
\code{\link{plot.robmlm}} for a plot method;
\code{\link[MASS]{rlm}}, \code{\link[MASS]{cov.trob}}

Other robust methods: 
\code{\link{Mahalanobis}()},
\code{\link{plot.robmlm}()}
}
\author{
John Fox; packaged by Michael Friendly
}
\concept{robust methods}
\keyword{multivariate}
\keyword{robust}
